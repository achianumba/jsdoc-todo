import { getConfig } from "./config";
import { ToDoPluginConfig } from "./types";
import { writeFileSync, existsSync, mkdirSync, readFileSync } from "fs";
import {parse as parsePath} from "path";

export function getToDoText(config: ToDoPluginConfig, todoList: Array<string>): string {
  const todoText = `${config.tag}
DO NOT MANUALLY EDIT THIS TO DO LIST !!!
THIS WHOLE SECTION, INCLUDING ITS HEADING IS AUTO-GENERATED BY \`jsdoc-todo\` plugin.
ALL MANUAL CHANGES WILL BE OVERWRITTEN THE NEXT TIME jsdoc RUNS !!!!

IF YOU MUST DIRECTLY/MANUALLY INCLUDE TO DO ITEMS IN THIS DOCUMENT,
PLEASE ADD THEM DIRECTLY BELOW THE "${config.endTag.slice(5, -4)}" HTML COMMENT BELOW. -->

${"#".repeat(config.headingLevel)} ${config.heading}

${todoList.join("\n")}

${config.endTag}

`;

  return todoText;
}

export function writeToDoToFile(file: string, todoText: string) {
  writeFileSync(
    file,
    `${todoText.trimEnd().replaceAll(/\r?\n{3,}/g, "\n\n")}\n`,
    { encoding: "utf-8" }
  );
}

export function save(todoList: Array<string>) {
  if (todoList.length === 0) {
    console.log("No 'to do' items/lists found!");
    return;
  }

  const config = getConfig();
  const outDir = parsePath(config.outFile).dir;
  const todoText = getToDoText(config, todoList);

  // Write the to do list to a new file.
  if (!existsSync(config.outFile)) {
    if (!existsSync(outDir)) {
      mkdirSync(outDir, { recursive: true });
    }

    writeToDoToFile(config.outFile, todoText);
    return;
  }

  const todoFile = String(readFileSync(config.outFile, { encoding: "utf-8" }));
  const startIndex = todoFile.indexOf(config.tag);

  // @todolist or the user-supplied tag is not found
  if (startIndex === -1) {
    writeToDoToFile(config.outFile, `${todoFile.trim()}${todoText}`);
    return;
  }

  let preceedingSections = todoFile.slice(0, startIndex).trim();

  if (preceedingSections) {
    preceedingSections = `${preceedingSections}\n\n`;
  }

  const stopIndex = todoFile.indexOf(config.endTag);
  let subsequentSections;

  // When the endTag (@endtodolist) is missing but the start tag is present
  if (stopIndex === -1) {
    /**
     * @todolist
     * Document caveat: All elements between the start tag and the last occurence of a markdown checkbox (- [] or -[x]) will be overwritten for a document that has a startTag but no end tag.
     * Maybe recommend that non-generated to do items should be before, not after the genrated content.
     */
    // Get highest index of a checkbox (i.e. the last)
    const lastCheckboxIndex = ["- [ ]", "- [x]", "- [X]"].reduce(
      (previousValue, checkbox) => {
        const currentValue = todoFile.lastIndexOf(checkbox);
        if (currentValue > previousValue) {
          return currentValue;
        }
        return previousValue;
      },
      -1
    );

    // First line break after checkbox (end of the line)
    let lineBreakIndex;

    if (lastCheckboxIndex > -1) {
      // Skip the whole line
      lineBreakIndex = todoFile.indexOf("\n", lastCheckboxIndex);

      // The last checkbox is the last line of the file.
      if (lineBreakIndex === -1) {
        writeToDoToFile(config.outFile, `${preceedingSections}${todoText}`);
        return;
      }

      // Skips the whole line
      subsequentSections = todoFile.slice(lineBreakIndex).trim();
      writeToDoToFile(
        config.outFile,
        `${preceedingSections}${todoText}${subsequentSections}`
      );
      return;
    }

    // Find To Do section's end by the section's heading
    const todoHeadingIndex = todoFile.indexOf(config.heading, startIndex);
    if (todoHeadingIndex === -1) {
      throw Error(
        `Unable to reliably determine determine the to do list's location in ${config.outFile}
      Consider deleting all auto-generated/to-do related text in the To Do section and try again of the file and try again.
      `
      );
    }

    // Skip entire heading (line)
    lineBreakIndex = todoFile.indexOf("\n", todoHeadingIndex);
    // Heading is the last line
    switch (lineBreakIndex) {
      case -1:
        writeToDoToFile(config.outFile, `${preceedingSections}${todoText}`);
        return;

      default:
        subsequentSections = todoFile.slice(lineBreakIndex).trim();
        writeToDoToFile(
          config.outFile,
          `${preceedingSections}${todoText}${subsequentSections}`
        );
        return;
    }

    //
  }

  const lineBreakIndex = todoFile.indexOf("\n", stopIndex);

  switch (lineBreakIndex) {
    case -1:
      writeToDoToFile(config.outFile, `${preceedingSections}${todoText}`);
      return;

    default:
      subsequentSections = todoFile.slice(lineBreakIndex).trim();
      writeToDoToFile(
        config.outFile,
        `${preceedingSections}${todoText}${subsequentSections}`
      );
      return;
  }
}

export default save;